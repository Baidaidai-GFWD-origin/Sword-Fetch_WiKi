import{_ as i,c as t,o as a,ae as n}from"./chunks/framework.B7HHgz8Z.js";const E=JSON.parse('{"title":"SwordFetch: 轻量级、更灵活的HTTP客户端","description":"","frontmatter":{},"headers":[],"relativePath":"docs/about.md","filePath":"docs/about.md"}'),e={name:"docs/about.md"};function l(h,s,p,k,d,r){return a(),t("div",null,s[0]||(s[0]=[n(`<h1 id="swordfetch-轻量级、更灵活的http客户端" tabindex="-1">SwordFetch: 轻量级、更灵活的HTTP客户端 <a class="header-anchor" href="#swordfetch-轻量级、更灵活的http客户端" aria-label="Permalink to &quot;SwordFetch: 轻量级、更灵活的HTTP客户端&quot;">​</a></h1><p>在Kotlin的世界里，当我们需要进行网络请求时，通常会想到两个名字：<code>OkHttp</code> 和 <code>Retrofit</code>。<code>OkHttp</code> 是一个强大而高效的底层HTTP客户端，而 <code>Retrofit</code> 则在其之上提供了一个类型安全的声明式API。</p><p><code>SwordFetch</code> 是一个新的选择，它同样基于 <code>OkHttp</code>，但旨在提供一种更轻量级、更接近前端开发体验（类似JavaScript的<code>fetch</code> API）的解决方案。</p><h2 id="横向对比" tabindex="-1">横向对比 <a class="header-anchor" href="#横向对比" aria-label="Permalink to &quot;横向对比&quot;">​</a></h2><table tabindex="0"><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">OkHttp</th><th style="text-align:left;">Retrofit</th><th style="text-align:left;">SwordFetch</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>抽象级别</strong></td><td style="text-align:left;">底层</td><td style="text-align:left;">高层 (声明式)</td><td style="text-align:left;">中层 (函数式)</td></tr><tr><td style="text-align:left;"><strong>核心理念</strong></td><td style="text-align:left;">高效、可靠的HTTP传输</td><td style="text-align:left;">类型安全的RESTful API接口</td><td style="text-align:left;">简洁、灵活、类似JS的<code>fetch</code></td></tr><tr><td style="text-align:left;"><strong>易用性</strong></td><td style="text-align:left;">相对繁琐，需手动构建请求</td><td style="text-align:left;">非常简单，通过注解定义接口</td><td style="text-align:left;">简单，单个<code>fetch</code>函数</td></tr><tr><td style="text-align:left;"><strong>类型安全</strong></td><td style="text-align:left;">弱</td><td style="text-align:left;">强</td><td style="text-align:left;">弱 (依赖手动解析)</td></tr><tr><td style="text-align:left;"><strong>灵活性</strong></td><td style="text-align:left;">非常高</td><td style="text-align:left;">相对受限（需预定义接口）</td><td style="text-align:left;">高（请求参数可动态构建）</td></tr><tr><td style="text-align:left;"><strong>依赖</strong></td><td style="text-align:left;"><code>okhttp</code></td><td style="text-align:left;"><code>okhttp</code>, <code>retrofit</code>, <code>converter</code></td><td style="text-align:left;"><code>okhttp</code>, <code>kotlinx.serialization</code></td></tr></tbody></table><hr><h2 id="深入分析" tabindex="-1">深入分析 <a class="header-anchor" href="#深入分析" aria-label="Permalink to &quot;深入分析&quot;">​</a></h2><p>为了更直观地理解三者差异，我们来看一个简单的GET请求示例。</p><h3 id="okhttp-基础构建者" tabindex="-1">OkHttp: 基础构建者 <a class="header-anchor" href="#okhttp-基础构建者" aria-label="Permalink to &quot;OkHttp: 基础构建者&quot;">​</a></h3><p><code>OkHttp</code> 是这一切的基础。使用它，你需要手动构建<code>Request</code>对象，然后执行它。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// OkHttp 示例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> client </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> OkHttpClient</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> request </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Request.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Builder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">url</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://api.example.com/data&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">header</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Content-Type&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;application/json&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">build</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">client.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newCall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(request).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { response </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">response.isSuccessful) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">throw</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> IOException</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Unexpected code </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$response</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(response.body</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><code>OkHttp</code> 赋予你完全的控制权，但代价是代码相对冗长。</p></div><h3 id="retrofit-声明式接口" tabindex="-1">Retrofit: 声明式接口 <a class="header-anchor" href="#retrofit-声明式接口" aria-label="Permalink to &quot;Retrofit: 声明式接口&quot;">​</a></h3><p><code>Retrofit</code> 的魔法在于它将HTTP API抽象为Kotlin/Java接口。你只需要定义接口和数据模型，剩下的交给它。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Retrofit 示例</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1. 定义API接口</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ApiService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @GET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;data&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    suspend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ResponseData</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2. 创建Retrofit实例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> retrofit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Retrofit.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Builder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">baseUrl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://api.example.com/&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addConverterFactory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Json.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">asConverterFactory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;application/json&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toMediaType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">client</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">OkHttpClient</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">build</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3. 创建服务并调用</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> service </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> retrofit.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ApiService::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.java)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> service.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p><code>Retrofit</code> 极大地简化了代码，并提供了编译时的类型安全检查，非常适合结构稳定的RESTful API。</p></div><h3 id="swordfetch-灵活的函数式调用" tabindex="-1">SwordFetch: 灵活的函数式调用 <a class="header-anchor" href="#swordfetch-灵活的函数式调用" aria-label="Permalink to &quot;SwordFetch: 灵活的函数式调用&quot;">​</a></h3><p><code>SwordFetch</code> 另辟蹊径，它不追求 <code>Retrofit</code> 的声明式接口，而是提供了一个核心的 <code>fetch</code> 函数，其设计哲学更贴近现代Web开发的习惯。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// SwordFetch 示例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> response </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://api.example.com/data&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 如果需要更复杂的配置</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> options </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HTTPOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;methods&quot;: &quot;POST&quot;,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;body&quot;: { &quot;key&quot;: &quot;value&quot; }</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    }</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> postResponse </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://api.example.com/submit&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, options)</span></span></code></pre></div><h2 id="swordfetch-的核心优势" tabindex="-1">SwordFetch 的核心优势 <a class="header-anchor" href="#swordfetch-的核心优势" aria-label="Permalink to &quot;SwordFetch 的核心优势&quot;">​</a></h2><ol><li><strong>极致轻量和简洁</strong>: 没有复杂的接口定义和构建器模式，只有一个核心的 <code>fetch</code> 函数，上手成本极低。</li><li><strong>前端开发者友好</strong>: API设计深受JavaScript <code>fetch</code> 启发，对于全栈或从前端转来的开发者来说非常自然。</li><li><strong>动态配置的灵活性</strong>: <code>HTTPOptions</code> 通过JSON字符串进行配置，这意味着请求的配置可以完全动态化。你可以从配置文件、远程服务或用户输入中加载请求参数，而无需修改或重新编译代码。这是 <code>Retrofit</code> 的静态接口难以实现的。</li></ol><div class="warning custom-block"><p class="custom-block-title">注意</p><p><code>SwordFetch</code> 在提供灵活性的同时，牺牲了部分编译时的类型安全。返回结果是原始字符串，需要开发者手动进行JSON解析和类型转换。</p></div><h2 id="何时选择-swordfetch" tabindex="-1">何时选择 SwordFetch？ <a class="header-anchor" href="#何时选择-swordfetch" aria-label="Permalink to &quot;何时选择 SwordFetch？&quot;">​</a></h2><ul><li><strong>快速原型开发</strong>: 当你需要快速实现网络请求功能，不想在定义大量接口上花费时间时。</li><li><strong>高度动态化的请求</strong>: 当请求参数（如请求方法、Header、Body）需要根据运行时逻辑动态生成时。</li><li><strong>轻量级项目或脚本</strong>: 对于一些简单的工具或脚本，引入 <code>Retrofit</code> 可能有些“杀鸡用牛刀”，<code>SwordFetch</code> 则恰到好处。</li><li><strong>前端背景的团队</strong>: 如果你的团队对 <code>fetch</code> API 非常熟悉，<code>SwordFetch</code> 可以提供一个无缝的开发体验。</li></ul><p>总而言之，<code>SwordFetch</code> 并非要取代 <code>Retrofit</code>，而是在 <code>OkHttp</code> 的强大基础上，提供了一个不同方向的、更轻、更灵活的解决方案。</p>`,25)]))}const c=i(e,[["render",l]]);export{E as __pageData,c as default};
